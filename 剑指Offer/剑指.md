



#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

难度简单293

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

**示例 1：**

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

**示例 2：**

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

**提示：**

- `1 <= values <= 10000`
- `最多会对 appendTail、deleteHead 进行 10000 次调用`

```cpp
// 思路很简单，就是用两个栈，一个来做输入一个来做输出，
// 只有当输出栈为空时才将输入栈中的元素都放入到输出栈中
// 第一次没有通过，是因为没有考虑两个栈都为空的情况
class CQueue {
public:
    stack<int> in;
    stack<int> out;
    CQueue() {
        
    }
    
    void appendTail(int value) {
        in.push(value);
    }
    
    int deleteHead() {
        if(in.empty() && out.empty()) return -1;
        if(out.empty()){
            while(!in.empty()){
                out.push(in.top());
                in.pop();
            }
        }
        int tmp = out.top();
        out.pop();
        return tmp;
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```

#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

难度简单173

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

 

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

 

**提示：**

1. 各函数的调用总次数不超过 20000 次

**思路还是很简单，用两个栈来模拟。一个栈就正常存储元素信息，而另一个栈则维持每个元素放入正常栈时的最小值，主要就是在min_stack push 入栈时判断此时的元素是否比栈中的最小值小，小的话就更新min_stack，否则继续维持之前的最小值。**

```cpp
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> all_stack;
    stack<int> min_stack;
    MinStack() {

    }
    
    void push(int x) {
        if(all_stack.empty()){
            all_stack.push(x);
            min_stack.push(x);
        }
        else{
            all_stack.push(x);
            min_stack.push( ::min(x, min_stack.top()));
        }
    }
    
    void pop() {
        all_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return all_stack.top();
    }
    
    int min() {
        return min_stack.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```



#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

难度简单150

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

**注意：**此题对比原题有改动

**示例 1:**

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

**说明：**

- 题目保证链表中节点的值互不相同
- 若使用 C 或 C++ 语言，你不需要 `free` 或 `delete` 被删除的节点

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 // 有点双指针的感觉，就是pre 和 cur 分别指向前后的元素，当找到val时就很方便的删除 pre->next = cur->next
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if(head == nullptr) return nullptr;
        if(head->val == val) return head->next;
        ListNode* cur = head->next;
        ListNode* pre = head;
        while(cur != nullptr && cur->val != val){
            pre = cur;
            cur = cur->next;
        }
        if(cur != nullptr){
            // 此时cur指向的就是要删除的 val
            pre->next = cur->next;
        }
        return head;
    }
};
```

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

难度简单184

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：1
```

**示例 2：**

```
输入：n = 5
输出：5
```

**提示：**

- `0 <= n <= 100`

```cpp
// 可以考虑使用递归，但是一些用例会超时
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;
        return fib(n-1) + fib(n-2);
    }
};
// 动规的思路，从底向上不需要从上往下递归
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;
        int pre0 = 0;
        int pre1 = 1;
        for(int i=2; i<=n; ++i){
            int sum = pre0 + pre1;
            pre0 = pre1;
            pre1 = sum % 1000000007;
        }
        return pre1;
    }
};
```



#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

难度简单222

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.

```

**双指针的思路，通过先让fast 指针走k步，之后当slow 和 fast 同步向后移动直到 fast为空时 slow 指向的即为目标节点。**

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        if(head == nullptr || k < 1) return nullptr;
        ListNode* fast = head;
        ListNode* slow = head;
        while(k--){
            if(fast != nullptr)
                fast = fast->next;
        }
        // 此时fast 和 slow 相距 k 个元素
        while(fast){
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```



#### 剑指 Offer 15. 二进制中1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。


示例 1：

输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```
// 其实首先想到的方法是，移动要比较的数n，每次向右移动一位，
// 但是这种解法对于，负数的测试用例是不满足的，因为负数是补码表示，右移之后会高位补1，这样会进入死循环
// 所以想到了向左去移动 比较的数 flag，当 & 操作之后的值大于0，就表示此时的位置是1，count++
// 但是此法，有多少位就需要移动多少次，有木有办法优化呢？
class Solution {
public:
     int  NumberOf1(int n) {
         int count = 0;
         unsigned int flag = 1;
         while(flag){
             if(n & flag)
                 count++;
             flag = flag << 1;
         }
         return count;
     }
};

// 一个最高效率的方法，当我们将一个整数减去1后，会把它最右边的1变成0，
// 如果它右边还有0的话所有的0都变成1，而它左边的所有位都保持不变，
// 然后将其与原数进行 与& ，就相当于是把它最右边的1变成0
// 最后的结论：把一个整数减去1，再和原整数做 与& 运算，会把该整数最右边的一个1变成0.
// 那么，此时，一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作
class Solution {
public:
     int  NumberOf1(int n) {
         int count = 0;
         while(n){
             ++count;
             n = (n-1) & n;
         }
         return count;
     }
};
```

#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

难度简单172

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**示例 1：**

```
输入：head = [1,3,2]
输出：[2,3,1]
```

**限制：**

```
0 <= 链表长度 <= 10000
```

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
// 思路简单，直接将链表存入栈中，然后出栈存储即可
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        vector<int> res;
        if(head == nullptr) return res;
        stack<int> stk;
        while(head){
            stk.push(head->val);
            head = head->next;
        }
        while(!stk.empty()){
            res.push_back(stk.top());
            stk.pop();
        }
    return res;
    }
};
```

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

难度简单284

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**限制：**

```
0 <= 节点个数 <= 5000
```

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 递归法 反转
        if(head == NULL) return head;
        if(head->next == NULL) return head; // 当此时链表只有一个节点时就返回节点本身就好
        ListNode* last_node = reverseList(head->next);
        head->next->next = head;  // 将下一个节点变成当前节点的前驱节点
        head->next = NULL;
        return last_node;
    }
};
// 此处有个很好的博客解释了 链表的反转，有图片很好理解递归法

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 迭代法 反转链表
        ListNode* pre = NULL;        // 已经逆序的链表的头节点
        while(head){
            ListNode* curr = head;  // 记录当前的head
            head = head->next;      // 更新head节点，供下次使用
            curr->next = pre;       // 将之前记录的head节点加入到pre中，pre中记录的是已经反转的链表
            pre = curr;             // 更新逆序部分的头节点pre
        }
    return pre;
    }
};
```





#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

难度中等261

请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。 
```

**提示：**

- `-10000 <= Node.val <= 10000`
- `Node.random` 为空（null）或指向链表中的节点。
- 节点数目不超过 1000 。

```cpp
```

