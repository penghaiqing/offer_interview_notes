#### 1、数组

数组存放的是**连续内存空间**上的相同类型数据的集合

需要注意的点：

- 数组下标是从0开始的
- 数组的内存空间地址是连续的
- 因为内存空间地址的连续性，对数组元素增删时就需要移动其他的元素，故不适合做频繁的增删操作。

**二维数组在内存的空间地址是连续的吗？**

**不是！！！二维数组其实是用一个线性数组存放其他数组的首地址。**

```
int [][] arr = new int[3][4]
// 首相是一个有3个元素的数组（3个元素的地址是连续的），
// 分别存放着3个数组的首地址（每个数组有4个元素，它们的地址是连续的），
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U2NjIzZWZlNGZhNWJkZDkzNTI3ZDdmNTkzNTQzYjNfOXRWYVNJRWpqNDhUWkpsTmJkeVV0a25IclpFYmRTVVdfVG9rZW46Ym94Y25QOUxRdldMN21GS09WTmtNeGVYckdnXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA)

如图，可清晰看到 3*4 的二维数组的内存地址不是完全连续的，其中的3个一维数组地址空间是连续的。

##### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

> 你可以假设数组中无重复元素。

> **示例 1:**

> **输入:** [1,3,5,6], 5

> **输出:** 2

> **示例 2:**

> **输入:** [1,3,5,6], 2

> **输出:** 1

> **示例 3:**

> **输入:** [1,3,5,6], 7

> **输出:** 4

> **示例 4:**

> **输入:** [1,3,5,6], 0

> **输出:** 0

```C++
// 暴力解法
// 有四种情况，
// 目标值在所有元素的最前面，等于数组中某个元素，插入数组中的位置，在数组所有元素之后

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0; i<nums.size(); ++i){
            if(nums[i] >= target){
                return i; // 如果有元素值大于或等于target，则就该target放在此元素之前或就是此元素
            }
        }
         return nums.size(); // 结束循环后，为target大于所有元素，此时放在最后即可
    }
};
// 时间复杂度：O(n)
// 空间复杂度：O(1)
```



```c++
// 二分法 关键是注意边界的问题
/*
    目标值在所有元素的最前面，[0, -1]
    目标值等于数组中某个元素，retutn middle
    目标值在插入数组中的位置，[left, right] return right+1，
         其实此时是二分查找到left>right后退出循环，此时没有元素与target匹配，需要插入到right+1处
    目标值在数组所有元素之后, [left, right] return right+1
*/

// 还有一种二分写法，即使用[left, right) 的右开区间，思路是一样的，循环条件和最后的返回值需要修改下
// while(left < right)  return right;
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0; 
        int right = n-1; // target 在区间[left, right] 闭区间
        while(left <= right) {
            int middle = (left + right) / 2;
            if(target < nums[middle]){
                right = middle - 1;
            } else if(target > nums[middle]){
                left = middle + 1;
            } else { // taget == nums[middle]
                return middle;
            }
        }
        return right + 1;
    }
};

// 时间复杂度：O(logn)
// 空间复杂度：O(1)
```

**二分查找的循环中，坚持循环不变的的原则。**

> 所谓循环不变量，是指在循环过程中保持不变的量。具体取什么样的量呢？显然，pi之类的常量在任何循环中都保持不变，但对分析循环并没有用处。

> 因此，为便于分析，循环不变量一般会取一个关于循环中的变量 V 的布尔函数 F，在整个循环过程中，F(V)为真，而当循环结束后，(F(V)->R)为真，R是循环的目的。这样，只要证明 F(V) ，即证明了这个循环达到了所要求的目的。



##### [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)二分法

> 难度 简单

> 实现 `int sqrt(int x)` 函数。

> 计算并返回 *x* 的平方根，其中 *x* 是非负整数。

> 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

> **示例 1:**

> **输入:** 4**输出:** 2

> **示例 2:**

> **输入:** 8**输出:** 2**说明:** 8 的平方根是 2.82842..., 

> ​     由于返回类型是整数，小数部分将被舍去。

```c++
class Solution {
public:
    int mySqrt(int x) {
        if(x == 0) return 0;
        if(x == 1) return 1;
        int left = 0;
        int right = x;
        int res = -1;
        while(left <= right){
            int mid = left + (right - left) / 2; // 防止相加溢出的情况
            if((long long) mid * mid > x){
                right = mid - 1;
            }else{
                res = mid;
                left = mid + 1;
            }
        }
        return res;
    }
};
```

##### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

难度 简单

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

示例 1：

**输入：**nums = [-4,-1,0,3,10] **输出：**[0,1,9,16,100]**解释：**平方后，数组变为 [16,1,0,9,100]

排序后，数组变为 [0,1,9,16,100]

```c++
// 思路一：直接将元素更新为 平方 ，之后调用 sort函数
// 思路二：使用双指针，从两头开始，比较两边的元素平方，然后将大的存入新的数组中，移动对应的指针

class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        // 双指针
        int n = nums.size();
        if(n == 0) return {};
        vector<int> res(n);
        int left = 0; 
        int right = n - 1;
        for(int pos = n-1 ; left <= right; ){
            if(nums[left]*nums[left] > nums[right]*nums[right]){
                res[pos] = nums[left]*nums[left];
                ++left;
            }else{
                res[pos] = nums[right]*nums[right];
                --right;
            }
            --pos;
        }
        return res;
    }
};

// 思路三： 也是双指针，但中间加入了归并的思路，
//      因为负数和正数平方后的顺寻会不同，所以将原数组中的元素分为负数和非负数来进行平方计算
//      再对两个有序的数组进行一次归并即可
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return {};
        int pos = -1;
        for(int i=0; i<n; ++i){
            if(nums[i] > 0){
                break;
            }
            pos = i;
        }
        // 此时pos指向最后一个为负的元素
        vector<int> res;
        int i = pos;
        int j = pos + 1;
        while(i >=0 && j < n){
            if(nums[i]*nums[i] < nums[j]*nums[j]){
                res.push_back(nums[i]*nums[i]);
                --i;
            }else{
                res.push_back(nums[j]*nums[j]);
                ++j;
            }
        }
        while(i >= 0){
            res.push_back(nums[i]*nums[i]);
            --i;
        }
        while(j < n ){
            res.push_back(nums[j]*nums[j]);
            ++j;
        }
        return res;
    }
};
```

##### [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

> 难度  简单

> 给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。

> **注意：**如果对空文本输入退格字符，文本继续为空。

>  

> **示例 1：**

> **输入：**S = "ab#c", T = "ad#c"**输出：**true**解释：**S 和 T 都会变成 “ac”。

> **示例 2：**

> **输入：**S = "ab##", T = "c#d#"**输出：**true**解释：**S 和 T 都会变成 “”。

```c++
// 比较直接暴力的思路是：使用栈了分别存储两个字符串，这样的话空间复杂度位O(m+n)
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int s_len = s.size();
        int t_len = t.size();
        if(s_len == 0 || t_len ==0) return false;
        stack<int> stk_s;
        stack<int> stk_t;
        for(int i=0; i<s_len; ++i){
            if(s[i] != '#'){
                stk_s.push(s[i]);
            }else if(!stk_s.empty()){
                stk_s.pop();
            }
        }
        for(int i=0; i<t_len; ++i){
            if(t[i] != '#'){
                stk_t.push(t[i]);
            }else if(!stk_t.empty()){
                stk_t.pop();
            }
        }
        if(stk_s.size() == stk_t.size()){
            while(!stk_s.empty() && !stk_t.empty()){
                if(stk_s.top() == stk_t.top()){
                    stk_s.pop();
                    stk_t.pop();
                }
                else
                    return false;
            }
            if(stk_s.empty() && stk_t.empty())
                return true;
            else
                return false;
        }else
            return false;
    }
};
```

**双指针解法：**

```c++
/*
由于 # 号只会消除左边的一个字符，所以对右边的字符无影响，所以选择从后往前遍历 S，T 字符串。

思路解析：

准备两个指针 i, j 分别指向 S，T 的末位字符，再准备两个变量 skipS，skipT 来分别存放 S，T 字符串中的 # 数量。
从后往前遍历 S，所遇情况有三，如下所示：
1 若当前字符是 #，则 skipS 自增 1；
2 若当前字符不是 #，且 skipS 不为 0，则 skipSskipS 自减 1；
3 若当前字符不是 #，且 skipS 为 0，则代表当前字符不会被消除，我们可以用来和 T 中的当前字符作比较。
若对比过程出现 S, T 当前字符不匹配，则遍历结束，返回 false，若 S，T 都遍历结束，且都能一一匹配，则返回 true。

*/
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int left = s.size() - 1;
        int right = t.size() - 1;
        // if(s_len == 0 || t_len ==0) return false;
        int skip_s = 0;
        int skipt = 0;
        while(left >=0 || right >= 0){
            while(left >=0 ){
                if(s[left] == '#'){
                    skip_s++;
                    left--;
                }else if(skip_s > 0){
                    skip_s--;
                    left--;
                }else{
                    break;
                }
            }
            while(right >= 0){
                if(t[right] == '#'){
                    skipt++;
                    right--;
                }else if(skipt > 0){
                    skipt--;
                    right--;
                }else{
                    break;
                }
            }

            if(left >=0 && right >= 0){
                if(s[left] != t[right]){
                    return false;
                }
            }else if(left >= 0 || right >= 0){
                return false;
            }
            left--;
            right--;
        }
        return true;
    }     
};
```



##### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

> 难度简单

> 给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

> 不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)****修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

>  **示例 1：**

> **输入：**nums = [1,1,2]

> **输出：**2, nums = [1,2]

> **解释：**函数应该返回新的长度 **2** ，并且原数组 *nums* 的前两个元素被修改为 **1**, **2** 。不需要考虑数组中超出新长度后面的元素。

> **示例 2：**

> **输入：**nums = [0,0,1,1,1,2,2,3,3,4]

> **输出：**5, nums = [0,1,2,3,4]

> **解释：**函数应该返回新的长度 **5** ， 并且原数组 *nums* 的前五个元素被修改为 **0**, **1**, **2**, **3**, **4** 。不需要考虑数组中超出新长度后面的元素。

```c++
// 暴力解法，因为数组有序，所以两层循环可以搞定，但是效率很低
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return n;
        for(int i=0; i<n-1; ++i){
            if(nums[i] == nums[i+1]){
                for(int j=i; j<n-1; ++j){
                    nums[j] = nums[j+1];
                }
                --i;
                n--;
            }
        }
        return n;
    }
};

// 双指针 解法 O(n)
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int fast = 1;
        int slow = 0;
        for( ; fast < n; ++fast){
            if(nums[slow] != nums[fast]){
                if(fast - slow > 1){ 
                // 此处的优化，当数组中没有重复元素时不需要，再进行复制操做
                    nums[slow+1] = nums[fast];
                }
                ++slow;
                
            }
        }
        return slow+1;
    }
};
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjNlZDdjM2JhYzQwMjU4NGMyZGFkMjljZjVjNzgzMTBfbm5ReERSQmx3dXpjSHQ4N0VyT3B1TmdkcVpiUlJ5UnZfVG9rZW46Ym94Y25Yc242blVxQkE1Y0ptRnJUSDRoaGllXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA)





##### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 *nums* 和一个值 *val*，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 *val* 的元素，并返回移除后数组的新长度。

> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)****修改输入数组**。

> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

> **示例 1:**

> 给定 *nums* = **[3,2,2,3]**, *val* = **3**,

> 函数应该返回新的长度 **2**, 并且 *nums* 中的前两个元素均为 **2**。

> 你不需要考虑数组中超出新长度后面的元素。

> **示例 2:**

> 给定 *nums* = **[0,1,2,2,3,0,4,2]**, *val* = **2**,

> 函数应该返回新的长度 **5**, 并且 *nums* 中的前五个元素为 **0**, **1**, **3**, **0**, **4**。

> 注意这五个元素可为任意顺序。

> 你不需要考虑数组中超出新长度后面的元素。

不能简单的想，把要移除的元素删除就好，因为数组地址是连续的，所以要采用**覆盖**的策略。

```c++
// 暴力解法
// 用两层for循环，第一层遍历数组，第二层移动元素更新数组
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // 暴力解法
        int n = nums.size();
        for(int i=0; i<n; ++i){
            if(nums[i] == val){
                for(int j=i; j<n-1; ++j){ // 此处的上界容易错，j<n-1，否则会crash
                    nums[j] = nums[j+1];
                }
                --i; // 此处易错，数组整体向前移动后，i下标也需要向前移动一位
                --n;
            } 
        }
        return n;
    }
};
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
// 双指针法 可以数量级的优化时间复杂度，O(n)
// 即快慢指针，当不是要删除的元素时，快慢指针同时增加，且 慢指针下标处元素 用快指针下标元素赋值
// 当是要删除的元素时，增加快指针而慢指针不变
// 这样，当遍历结束时，慢指针的下标大小即为 此时数组中的元素个数
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowP = 0;
        int fastP = 0;
        for(int fastP=0; fastP<nums.size(); ++fastP){
            if(val != nums[fastP]){
                nums[slowP++] = nums[fastP];
            }
        }
        return slowP;
    }
};
```

> [一篇双指针技巧的总结](https://blog.csdn.net/Perrysky/article/details/105298686)

##### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> 难度简单1034

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

> **示例:**

> **输入:** 

> [0,1,0,3,12]

> **输出:** 

> [1,3,12,0,0]

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 双指针思路，先将非零的元素一个个向前移动，覆盖为0 的元素位置
        // 之后再对最后进行补零
        int size = nums.size();
        if(size == 0) return ;
        int slow = 0;
        int fast = 0;
        for(; fast<size; ++fast){
            if(nums[fast] != 0){
                nums[slow++] = nums[fast];
            }
        }
        while(slow < size){
            nums[slow++] = 0;
        }
        return;
    }
};
```

##### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

> 难度  简单 

> 统计一个数字在排序数组中出现的次数。

> **示例 1:**

> **输入:** nums = [

> 5,7,7,8,8,10], target = 8**输出:** 2

> **示例 2:**

> **输入:** nums = [

> 5,7,7,8,8,10], target = 6**输出:** 0

<img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTY5OGI0YjkxMzg2ZGI4MWUwYWExYjZjNjM4NTJjMTlfSWVJZVJCMzlYS3pVVEphbnZpUGk3ZFk5YWZ4WjM2a3RfVG9rZW46Ym94Y25ubElqWGdQZFlvYkVwOEc3TDBqOVZjXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA" alt="img" style="zoom:67%;" />



```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(n == 0) return 0;
        // 搜索 右边界
        int i = 0, j = n - 1;
        while(i <= j){
            int mid = i + (j - i) / 2;
            if(nums[mid] <= target){
                i = mid + 1;
            }else{
                j = mid - 1;
            }
        }
        int right = i;
        i = 0, j = n - 1;
        while(i <= j){
            int mid = i + (j - i) / 2;
            if(nums[mid] < target){
                i = mid + 1;
            }else{
                j = mid - 1;
            }
        }
        int left = j;
        return right - left - 1;
    }
};

// 可以考虑将求 边界的 方法写成一个函数，
// 这样直接求 target的右边界和 target-1 的右边界，相减即为所求
class Solution {
public:
    int get_rightedge(vector<int>& nums, int target){
        int n = nums.size();
        if(n == 0) return 0;
        // 搜索 右边界
        int i = 0, j = n - 1;
        while(i <= j){
            int mid = i + (j - i) / 2;
            if(nums[mid] <= target){
                i = mid + 1;
            }else{
                j = mid - 1;
            }
        }
        int right = i;
        return right;
    }
    int search(vector<int>& nums, int target) {
        int left = get_rightedge(nums, target-1);
        int right = get_rightedge(nums, target);
        
        return right - left;
    }
};
```

> 与上题 53 相似，返回值略有不同

##### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

> 难度 中等

> 给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。

> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

> **进阶：**

- > 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

>  

> **示例 1：**

> **输入：**nums = [

> 5,7,7,8,8,10], target = 8**输出：**[3,4]

> **示例 2：**

> **输入：**nums = [

> 5,7,7,8,8,10], target = 6**输出：**[-1,-1]

> **示例 3：**

> **输入：**nums = [], target = 0**输出：**[-1,-1]

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        vector<int> res;
        if(n == 0) return {-1, -1};
        // 右边界
        int i = 0;
        int j = n - 1;
        while(i <= j){
            int mid = i + (j - i) / 2;
            if(nums[mid] <= target){
                i = mid + 1;
            }
            else{
                j = mid - 1;
            }
        }
        int right = i - 1;
        cout << "right : " << right << endl;
        //if(nums[right] != target) return {-1, -1};
        // 左边界
        i = 0, j = n - 1;
        while(i <= j){
            int mid = i + (j - i) / 2;
            if(nums[mid] < target){
                i = mid + 1;
            }
            else{
                j = mid - 1;
            }
        }
        int left = j + 1;
        cout << "left : " << left << endl;
        
        if(left<0 || right>n-1 || left > right) return {-1, -1};
        return {left, right};
    }
};


// 也可以像 53 题一样， 求出target的右边界 和 target-1 的右边界
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        vector<int> res;
        if(n == 0) return {-1, -1};
        int right = find_rightedge(nums, n, target);
        //cout << nums[right] << endl;
        int left = find_rightedge(nums, n, target-1);
        //cout << nums[left] << endl;
        if(left<0 || right>n || (right-1)<left)
            return {-1, -1};
        return {left, right-1};
    }
    int find_rightedge(vector<int> &nums, int n, int target){
        int i = 0;
        int j = n - 1;
        while(i <= j){
            int mid = i + (j - i) / 2;
            if(nums[mid] <= target){
                i = mid + 1;
            }else{
                j = mid - 1;
            }
        }
        return i;
    }
};
```



##### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的 **连续** 子数组，并返回其长度**。**如果不存在符合条件的子数组，返回 0。

**示例：**

**输入：**s = 7, nums = [2,3,1,2,4,3]

**输出：**2

**解释：**子数组 [4,3]是该条件下的长度最小的子数组。

```
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        // 暴力解法 两层循环
        int res = INT32_MAX;
        int sub_res = 0;
        int sum;
        for(int i=0; i<nums.size(); i++){
            sum = 0;
            for(int j=i; j<nums.size(); ++j){
                sum += nums[j];
                if(sum >= s){
                    sub_res = j - i + 1;
                    res = res < sub_res? res : sub_res; // 只要满足条件就更新子数组的长度
                    break; // 找的是最小的子序列，故只要满足条件就跳出循环
                }
            }
        }
        return res == INT32_MAX? 0 : res;
    }
};
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
```

> 滑动窗口算法的思路：

> （问题描述如： 在字符串S中找出：包含T所有字母的最小子串）

> 1) 我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引闭区间 [left, right] 称为⼀个「窗口」。

> 2) 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。

> 3) 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了），此时上一个状态即为此时left处能找到的最小字串。 当然，每次增加 left，我们都要更新字串的大小；紧接着再增加right。

> 4) 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

> 时间复杂度可以优化到 O(n)

```c++
// 滑动窗口解法，也是上道题目中提出的双指针的一种情况
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int res = INT32_MAX;
        int left = 0, right = 0;
        int sub_res = 0; // 窗口的长度
        int sum = 0; // 窗口中元素的和
        while(right < nums.size()){
            sum += nums[right];
            while(sum >= s){
                sub_res = right - left + 1;
                res = res < sub_res? res : sub_res;
                sum -= nums[left]; // 要增加left就需要将窗口中算进去的left元素减去，即缩小窗口中元素的大小
                ++left;
            }
            ++right;
        }
        return res == INT32_MAX? 0 : res;
    }
};
// 之前看到的 labuladong的滑动窗口模板

int left = 0, right = 0;

while (right < s.size())

{

    window.add(s[right]); // 右边的元素加入窗口

    right++; // 注意right移动的位置，若之后的while循环中需要使用的话，需要最后再增加right

    while (valid)

    {

        window.remove(s[left]); // 左边的元素移出窗口

        left++; 

    } 
```

##### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给定一个正整数 *n*，生成一个包含 1 到 *n*2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**示例:**

**输入:** 3

**输出:**

```C++
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
// 此题很考察代码控制能力，而关键就是全程遵循一个原则，如：左闭右开。保证对4条边的填充都是这样
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        // 此题就是模拟一遍旋转的过程，但是关键是： 旋转要遵循一个规律（如：左闭右开，见图片分析）
        // 正方形有4条边，考虑用4个for循环来模拟四个边
        // 需要判断的情况是，当n为奇数时，正方形中间为一个数，需要单独赋值
        vector<vector<int>> res(n,vector<int>(n,0)); // 定义全为0的二维数组
        int x = 0, y = 0;
        int count = 1; // 将要循环填入数组的元素值，默认为1
        int offset = 1; // 用来控制每条边的长度，开始是最后需要空出一位
        int loop = n / 2; // 需要循环的圈数
        while(loop--){
            int i = x, j = y;
            // 上行，从左到右（左闭右开）
            for(j=y; j<y+n-offset; ++j){
                res[x][j] = count++;
            }
            // 右列，从上到下（左闭右开）
            for(i=x; i<x+n-offset; ++i){
                res[i][j] = count++; // 此处易错点，列坐标为j（已经增长到最右边，而不是y）
            }
            // 下行，从右到左（左闭右开）
            for(; j>y; --j ){
                res[i][j] = count++;
            }
            // 左列，从下到上（左闭右开）
            for(; i>x; --i){
                res[i][j] = count++;
            }
            // 开始下一圈循环前，需要更新x，y
            x++;
            y++;
            // offset 也需要更新
            offset += 2;
        }
        // 如果n为奇数需要对中间的元素单独处理
        if(n %2 == 1){
            res[n/2][n/2] = count;
        }
        return res;
    }
};
```

<img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZThjYjVjZGI4N2JhNzc2OTIyNmRiYjk5NWYwNmIzZTFfZkxpVVZkaVpNZG1OY2QxczR0blNKblRpNWl2eXNUMHZfVG9rZW46Ym94Y25WYnBibE5LVG1RZmdKNkU2REZKU0NnXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA" alt="img" style="zoom:50%;" />

<img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQwNGZjNDI3ODgxZWEyYTVmNjI5YzEwNDE2MGNhOGFfYVpwSFlqWmdzQzdxZkRMM2xjbWU4cENWdE9zSmF3Q1hfVG9rZW46Ym94Y24yUXg1RzM4WnA4TkFIZzdCWTdKb2tnXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA" alt="img" style="zoom:50%;" />

#####  [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

> 难度 简单

> 给你两个有序整数数组 `nums1`和`nums2`，请你将`nums2`合并到 `nums1`中*，*使`nums1`成为一个有序数组。

> 初始化 `nums1`和`nums2`的元素数量分别为 `m`和`n`。你可以假设 `nums1`的空间大小等于 `m + n`，这样它就有足够的空间保存来自`nums2`的元素。

> **示例 1：**

> **输入：**nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3**输出：**[1,2,2,3,5,6]

> **示例 2：**

> **输入：**nums1 = [1], m = 1, nums2 = [], n = 0**输出：**[1]

> **提示：**

- > `nums1.length == m + n`

- > `nums2.length == n`

- > `0 <= m, n <= 200`

- > `1 <= m + n <= 200`

- > `-109<= nums1[i], nums2[i] <= 109`

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int len = m + n;
        while(m>0 && n>0){
            if(nums1[m-1] < nums2[n-1]){
                nums1[len-1] = nums2[n-1];
                --len;
                --n;
            }else{
                nums1[len-1] = nums1[m-1];
                --len;
                --m;
            }
        }
        while(n){
            nums1[len-1] = nums2[n-1];
            --len;
            --n;
        }
        return;
    }
};
```



##### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

> 难度中等

> 以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

> **示例 1：**

> **输入：**intervals = [[1,3],[2,6],[8,10],[15,18]]

> **输出：**[[1,6],[8,10],[15,18]]

> **解释：**区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

> **示例 2：**

> **输入：**intervals = [[1,4],[4,5]]

> **输出：**[[1,5]]

> **解释：**区间 [1,4] 和 [4,5] 可被视为重叠区间。

```c++
/*
对左边界排序，如果下一个区间的左边界在前一个的有边界内，考虑是否要更新边界，
如果如果下一个区间的左边界在前一个的有边界外，说明区间无法合并，开始计算下一个区间
*/
static bool my_compare(vector<int> a, vector<int> b){
    if(a[0] == b[0]) return a[1] < b[1];
    return a[0] < b[0];
}
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        int len = intervals.size();
        vector<vector<int>> res;
        if(len == 0) return res;
        sort(intervals.begin(), intervals.end(), my_compare);
        for(int i=1; i<len; ++i){
            if(intervals[i][0] <= intervals[i-1][1]){
                intervals[i][0] = min(intervals[i][0], intervals[i-1][0]);
                intervals[i][1] = max(intervals[i][1], intervals[i-1][1]);

            }else{
                res.push_back({intervals[i-1][0], intervals[i-1][1]});
            }
        }
        res.push_back({intervals[len-1][0], intervals[len-1][1]});
        return res;

    }
};
```





##### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> 难度中等

> 给你 `n` 个非负整数 `a1，a2，...，an`，每个数代表坐标中的一个点 `(i, ai)` 。在坐标内画 `n` 条垂直线，垂直线 `i` 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

> **说明：**你不能倾斜容器。

>  

> **示例 1：**

> ![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmE4MTViZjk0NjY5NDAyMDU2ZGM5N2RhOTUwZTIyOTFfYXRmWk5OTjJ1SHpmVVdDNUNnam9NMkxVZ2dneXdEWkVfVG9rZW46Ym94Y25IV3h2YzdZTjBXRTVQM3VoSmxVM3VmXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA)

> **输入：**[1,8,6,2,5,4,8,3,7]**输出：**49 **解释：**图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

> **示例 2：**

> **输入：**height = [1,1]**输出：**1

> **示例 3：**

> **输入：**height = [4,3,2,1,4]**输出：**16

> **示例 4：**

> **输入：**height = [1,2,1]**输出：**2

>  

> **提示：**

- > `n = height.length`

- > `2 <= n <= 3 * 104`

- > `0 <= height[i] <= 3 * 104`

```C++
/*
    对O(n)的算法写一下自己的理解，
    一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，
    接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，
    就只有在容器的 高 上下功夫。 那我们该如何决策哪个指针移动呢？
    因为不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了1。
    这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，
    所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，
    放弃了较小的那条边，以获得有更高的边的机会
*/
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int res = 0;
        while(left < right){
            res = max(res ,max_water(height[left], height[right], left, right));
            if(height[left] < height[right])
                ++left;
            else
                --right;
        }
        return res;
    }

private:
    int max_water(int left_hight, int right_high, int l, int r){
        int res = 0;
        if(left_hight > right_high){
            res = (r-l) * right_high;
        }else{
            res = (r-l) * left_hight;
        }
        return res;
    }

};
```

##### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

> 难度困难

> 给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

> **示例 1：**

> ![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzdhNjAxYTM4M2RhNzRmZmUwMTdlODUzZGE2YmYyNTlfdG4yc2ZOQXhMWlh4ejN1eGY2anhhWmprUkQ4SjZDYWRfVG9rZW46Ym94Y25EVllBUHhyTnFQTWpLNkpiUkFMcU5jXzE2MjMzOTQzODc6MTYyMzM5Nzk4N19WNA)

> **输入：**height = [0,1,0,2,1,0,1,3,2,1,2,1]**输出：**6**解释：**上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

> **示例 2：**

> **输入：**height = [4,2,0,3,2,5]

> **输出：**9

```c++
/*
    1、在某个位置i处，它能存的水，取决于它左右两边的最大值中较小的一个。
    2、当从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max是不可信的。
    3、当从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max是不可信的。
        所以我们用两个指针维持一个可信的区间。
    4、而我们要计算的能够盛水的量，可以通过计算每一个列（即竖着的蓝色长条）的累加得到。
    即通过双指针遍历所有的列，将每个列中的蓝色长条相加。
*/

class Solution {
public:
    int trap(vector<int>& height) {
        int len = height.size();
        if(len == 0) return 0;
        int res = 0;
        int left = 0;
        int right = len - 1;
        int left_max = height[left];
        int right_max = height[right];
        while(left < right){
            left_max = max(left_max, height[left]);
            right_max = max(right_max, height[right]);
            if(left_max < right_max){
                res += (left_max - height[left]);
                ++left;
            }else{
                res += (right_max - height[right]);
                --right;
            }
        }
        return res;
    }
};
```

##### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

> 难度 中等 

> 在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

> **示例 1:**

> **输入:** 

> [3,2,1,5,6,4] 和k = 2

> **输出:** 5

> **示例 2:**

> **输入:** 

> [3,2,3,1,2,4,5,5,6] 和k = 4

> **输出:** 4

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i=n/2; i>=0; --i){
            sink(nums, i, n-1);
        }
        int res;
        for(int i=n-1, j=0; j<k; ++j, --i){
            int tmp = nums[0];
            nums[0] = nums[i];
            if(j == k-1){
                res = tmp;
                break;
            }
            sink(nums, 0, i-1);
        }
        return res;
    }
private:
    void sink(vector<int>& arr, int low, int high){
        int i = low, j = 2*i + 1;
        int tmp = arr[i];
        while(j <= high){
            if(j<high && arr[j] < arr[j+1])
                ++j;
            if(tmp < arr[j]){
                arr[i] = arr[j];
                i = j;
                j = 2*i + 1;
            }else{
                break;
            }
        }
        arr[i] = tmp;
    }
};
```